#!/usr/bin/env python
'''
coilpy is a python library for plasma physics and coil designing.
Maintained by CaoXiang ZHU (czhu@pppl.gov)

Table of contents:
1. read plasma boundary (FOCUS format);
2. plot the plasma surface (several types plotting);
3. read the poincare plot data generated by GLASS;
4. get the data from a sequence FOCUS run;
5. read coils.xxx file;
6. tansform spline2xys format data into a coils file;
7. plot the coils;
8. produce an array of color rgb float triplets;
'''
#QT_API imcompactible
import sip
API_NAMES = ["QDate", "QDateTime", "QString", "QTextStream", "QTime", "QUrl", "QVariant"]
API_VERSION = 2
for name in API_NAMES:
    sip.setapi(name, API_VERSION)
from PyQt4.QtCore import *
from PyQt4.QtGui import *
from PyQt4.QtSvg import *
from PyQt4.QtCore import pyqtSignal as Signal
from PyQt4.QtCore import pyqtSlot as Slot

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import os.path
from matplotlib import cm
import h5py
from mayavi import mlab
import colorsys

#------------------------------------------  1  ----------------------------------------------------
def read_plasma_boundary(filename):
    '''
    The function read plasma.boundary file in FOCUS format and return
    a structured np.array with [n, m, Rbc, Rbs, Zbc, Zbs]
    '''
    with open(filename, 'r') as f:
        line = f.readline() #skip one line
        line = f.readline()
        num = int(line.split()[0]) #harmonics number
        nfp = int(line.split()[1]) #number of field periodicity
        nbn = int(line.split()[2]) #number of Bn harmonics
        plas_data = np.zeros(num, dtype=[('n', np.float32),('m',np.float32), #m,n saving as double
                                         ('Rbc',np.float32), ('Rbs', np.float32),
                                         ('Zbc',np.float32), ('Zbs', np.float32)])
        line = f.readline() #skip one line
        line = f.readline() #skip one line
        for i in range(num):
            line = f.readline()
            plas_data[i] = tuple([float(j) for j in line.split()])
        plas_data['n'] *= nfp

        if nbn>0 :
            bn_data = np.zeros(nbn, dtype=[('n', np.float32),('m',np.float32),
                                           ('bnc', np.float32),('bns',np.float32)])
            line = f.readline() #skip one line
            line = f.readline() #skip one line
            for i in range(nbn):
                line = f.readline()
                bn_data[i] = tuple([float(j) for j in line.split()])
        else :
            bn_data = []        
    print "read {} Fourier harmonics for plasma boundary and {} for Bn distribution in {}."\
        .format(num,nbn,filename)
    return plas_data, bn_data
        
#------------------------------------------  2  ----------------------------------------------------
def plot_plasma_boundary(filename,plotype='cross-section',zeta=0.0, zeta1=2*np.pi,
                         c='r',style='-',width=2.0,lbl='plasma boundary',npol=128,ntor=128):
    '''
    plot the plasma boundary;
    plotype:
            cross-section -> 2D plot at zeta plane
            surface       -> 3D surface using matplotlib
            bnormal       -> 3D surface plot with Bn scalar using mayavi
    '''
    plas, bfou = read_plasma_boundary(filename)
    maxR, minR, maxZ, minZ = 0.0, 999.0, 0.0, 999.0
    if plotype=='cross-section' : #plot cross-section
        npoints = 360 #number of points
        theta = np.linspace(0,2* np.pi, npoints)
        r = np.zeros(npoints)
        z = np.zeros(npoints)
        for ipoint in range(npoints):
            tmpr = plas['Rbc']*np.cos(plas['m']*theta[ipoint]-plas['n']*zeta) + \
                   plas['Rbs']*np.sin(plas['m']*theta[ipoint]-plas['n']*zeta)
            r[ipoint] = np.sum(tmpr) #r value at ipont
            maxR = max(np.sum(tmpr), maxR)
            minR = min(np.sum(tmpr), minR)

            tmpz = plas['Zbc']*np.cos(plas['m']*theta[ipoint]-plas['n']*zeta) + \
                   plas['Zbs']*np.sin(plas['m']*theta[ipoint]-plas['n']*zeta)
            z[ipoint] = np.sum(tmpz) #z value at ipont
            maxZ = max(np.sum(tmpz), maxZ)
            minZ = min(np.sum(tmpz), minZ)
        plt.plot(r, z, color=c,linewidth=width,linestyle=style,label=lbl)
        return maxR, minR, maxZ, minZ
    elif plotype == 'surface' : #plot surface
        if plt.get_fignums():
            fig = plt.gcf()
        else :
            fig = plt.figure()
        ax = fig.gca(projection='3d')
        x=np.zeros((npol+1,ntor+1))
        y=np.zeros((npol+1,ntor+1))
        z=np.zeros((npol+1,ntor+1))
        for i in range(ntor+1):
            ator = zeta + i*(zeta1-zeta)/ntor #zeta
            for j in range(npol+1):
                apol = j*2*np.pi/npol #theta
                tmpr = plas['Rbc']*np.cos(plas['m']*apol-plas['n']*ator) + \
                       plas['Rbs']*np.sin(plas['m']*apol-plas['n']*ator)
                tmpz = plas['Zbc']*np.cos(plas['m']*apol-plas['n']*ator) + \
                       plas['Zbs']*np.sin(plas['m']*apol-plas['n']*ator)
                maxR = max(np.sum(tmpr), maxR)
                minR = min(np.sum(tmpr), minR)
                maxZ = max(np.sum(tmpz), maxZ)
                minZ = min(np.sum(tmpz), minZ)
                x[j,i] = np.sum(tmpr) * np.cos(ator)
                y[j,i] = np.sum(tmpr) * np.sin(ator)
                z[j,i] = np.sum(tmpz)
        ax.plot_surface(x,y,z,color='white')
        #p1 = [x[npol/2  ,ntor/2  ], y[npol/2  ,ntor/2  ], z[npol/2  ,ntor/2  ]]
        #p2 = [x[npol/2+1,ntor/2  ], y[npol/2+1,ntor/2  ], z[npol/2+1,ntor/2  ]]
        #p3 = [x[npol/2  ,ntor/2+1], y[npol/2  ,ntor/2+1], z[npol/2  ,ntor/2+1]]
        #p4 = [x[npol/2+1,ntor/2+1], y[npol/2+1,ntor/2+1], z[npol/2+1,ntor/2+1]]
        return maxR, minR, maxZ, minZ
    elif plotype == 'surface3d' :
        x=np.zeros((npol+1,ntor+1))
        y=np.zeros((npol+1,ntor+1))
        z=np.zeros((npol+1,ntor+1))

        for i in range(ntor+1):
            ator = zeta + (i+0.5)*(zeta1-zeta)/ntor #zeta
            for j in range(npol+1):
                apol = (j+0.5)*2*np.pi/npol #theta
                tmpr = plas['Rbc']*np.cos(plas['m']*apol-plas['n']*ator) + \
                       plas['Rbs']*np.sin(plas['m']*apol-plas['n']*ator)
                tmpz = plas['Zbc']*np.cos(plas['m']*apol-plas['n']*ator) + \
                       plas['Zbs']*np.sin(plas['m']*apol-plas['n']*ator)
                maxR = max(np.sum(tmpr), maxR)
                minR = min(np.sum(tmpr), minR)
                maxZ = max(np.sum(tmpz), maxZ)
                minZ = min(np.sum(tmpz), minZ)
                x[j,i] = np.sum(tmpr) * np.cos(ator)
                y[j,i] = np.sum(tmpr) * np.sin(ator)
                z[j,i] = np.sum(tmpz)                
        #fig = mlab.figure(bgcolor=(1,1,1),fgcolor=(0,0,0),size=(600,600))
        mlab.mesh(x,y,z,color=(1, 0, 0))
        return maxR, minR, maxZ, minZ
    elif plotype == 'bnormal' :
        x=np.zeros((npol+1,ntor+1))
        y=np.zeros((npol+1,ntor+1))
        z=np.zeros((npol+1,ntor+1))
        targetBn = np.zeros((npol+1,ntor+1))

        for i in range(ntor+1):
            ator = zeta + (i+0.5)*(zeta1-zeta)/ntor #zeta
            for j in range(npol+1):
                apol = (j+0.5)*2*np.pi/npol #theta
                tmpr = plas['Rbc']*np.cos(plas['m']*apol-plas['n']*ator) + \
                       plas['Rbs']*np.sin(plas['m']*apol-plas['n']*ator)
                tmpz = plas['Zbc']*np.cos(plas['m']*apol-plas['n']*ator) + \
                       plas['Zbs']*np.sin(plas['m']*apol-plas['n']*ator)
                tmpb = bfou['bnc']*np.cos(bfou['m']*apol-bfou['n']*ator) + \
                       bfou['bns']*np.sin(bfou['m']*apol-bfou['n']*ator)
                x[j,i] = np.sum(tmpr) * np.cos(ator)
                y[j,i] = np.sum(tmpr) * np.sin(ator)
                z[j,i] = np.sum(tmpz)
                targetBn[j,i] = np.sum(tmpb)
        #fig = mlab.figure(bgcolor=(1,1,1),fgcolor=(0,0,0),size=(600,600))
        mlab.mesh(x,y,z,scalars=targetBn, colormap='RdBu')
        return targetBn
    else :
        raise NameError("No such option!")
        print "plotype = cross-section/surface/bnormal"
        

#------------------------------------------  3  ----------------------------------------------------
def read_ppfile(ppfile):
    '''
    INPUT : ppfile (string, the poincare plot (pp) binary file path and name)
    OUTPUT: R, Z (list, the two lists represent the data in R and Z)
    DETAIL: This function read a pp file and return the data in two lists, used for GGLASS/FOCUS
            pp file. (The two have slightly differences at the header.)
    '''
    r = np.array([])
    z = np.array([])
    with open(ppfile, 'rb') as f:
        while True:
            head = np.fromfile(f, dtype=np.int32, count=1) #fortran unformatted header
            #detect end of file
            if not head:
                break
            length = head[0]
            #print(length)
            npoints = np.fromfile(f, dtype=np.int32, count=length/4)[0] #length/4 = no. of integers
            #print(npoints)
            nonuse = f.read(8)
            rzdata = np.fromfile(f, dtype=np.float64, count=2*(1+npoints)) #reading all the R,Z data
            #print(len(rzdata))
            rzdata = rzdata.reshape(1+npoints,2)
            r = np.append(r, rzdata[:,0])
            z = np.append(z, rzdata[:,1])
            nouse = f.read(4)  #skip write ender
    return r, z
 
#------------------------------------------  3  ----------------------------------------------------
def sequence_h5_data(prefix, variable, result, istart, istop, istep, itype):
    '''
    INPUT : prefix   (string, the path and prefix, like'./seq.NC')
          : variable (string, the variable name that is varying, like 'Ncoils')
          : result   (string, the result term that want to be plotted, like 'Bnorm')
          : istart   (int   , starting number)
          : istop    (int   , stopping number)
          : istep    (int   , stepp size)
          : ityp     (strung, either "times" or "plus", selecting different loop type)
    OUTPUT: rslt     (list/np.array, rslt[i] = [tau, bnorm])
    DETAIL: This function reads the result data in mulptiple files, used for FOCUS sequence running
    '''
    suffix = '.fo.h5'
    #get number of files and generating looped names
    if itype == 'times':
        N=istop-istart+1
        numbers = [istep**exp for exp in range(istart, istop)]
        numbers.insert(0,0)
    elif itype == 'plus':
        N=(istop-istart)/istep + 1
        numbers = range(istart, istop + istep, istep)
    else:
        raise NameError("Either 'plus' or 'times'")
    filename = [prefix + '=+' + str(x).zfill(6) + suffix for x in numbers]

    rslt = [] #empty list

    for iname in filename:
        with h5py.File(iname,'r') as h5_fid:
            evolution = h5_fid['evolution'].value
            marker = str(h5_fid[variable].value[0])
            tau = evolution[0,:]
            energy = evolution[1,:]
            deriv = evolution[2,:]
            bnorm = evolution[3,:]
            tflux = evolution[4,:]
            ttlen = evolution[5,:]
            rslt.append([tau,bnorm])  #append[tau, bnorm]; will be changed later
    return rslt
#------------------------------------------  4  ----------------------------------------------------
class coil(object):
    '''
    coil class
    '''
    name = 'default name'
    I = 0.0
    def __init__(self):
        self.x = []
        self.y = []
        self.z = []
    
def readcoils(filename):
    '''
    filename : the path for the coils file
    return an array of coil class;
    '''

    ncoil = 0
    with open(filename,'r') as coilfile: #get each coil segments number
        coilfile.readline()
        coilfile.readline()
        coilfile.readline()
        for line in coilfile:
            if line[0:2] == 'end':
                break
            
            if len(line.split()) > 4 :
                ncoil = ncoil + 1
                continue
    print "Read {} coils in {}.".format(ncoil, filename)
    coildata = np.ndarray((ncoil,),dtype=np.object)
    with open(filename,'r') as coilfile: #read coil xyz and I
        coilfile.readline()
        coilfile.readline()
        coilfile.readline()
        icoil = 0
        coildata[0] = coil()
        for line in coilfile:
            linelist = line.split()
            if len(linelist) < 4 :
                print"End of file or invalid format!"
                break
            coildata[icoil].x.append(float(linelist[0]))
            coildata[icoil].y.append(float(linelist[1]))
            coildata[icoil].z.append(float(linelist[2]))
            if len(linelist) == 4 :
                coildata[icoil].I = float(linelist[-1])
            if len(linelist) > 4 :
                coildata[icoil].name = linelist[-1]
                #print "get one new coil"
                icoil = icoil + 1
                if icoil >= ncoil :
                    break
                coildata[icoil] = coil()
                continue
        if icoil != ncoil:
            raise CountingError("The number of coils doesn't match!")
        return(coildata)
#------------------------------------------  5  ----------------------------------------------------
def xyz2coils(xyzname,coilsname):
    '''
    This function read sxyz.dat produced by spline2xyz and then write into a coils file
    INPUT  : xyzname  (string, filename for xyzdata)
    OUTPUT : coilsname(string, filename for coils file)
    '''
    x = []
    y = []
    z = []
    c = []
    n = []
    with open(xyzname, 'r') as xyzfile:
        for line in xyzfile:
            tmp=line.split()
            x.append(float(tmp[0]))
            y.append(float(tmp[1]))
            z.append(float(tmp[2]))
            c.append(float(tmp[3]))
            n.append(int (tmp[-1]))
    num = len(x)
    data = np.zeros(num, dtype=[('xyzc',np.float32,(1,4)), ('n',np.int)])
    for i in range(num):
        data[i] = ([x[i],y[i],z[i],1.0E7], n[i])
    coilnum = set(data['n'])

    with open(coilsname,'w') as coilsfile:
        coilsfile.write('periods 1'+'\n')
        coilsfile.write('begin filament'+'\n')
        coilsfile.write('mirror NUL'+'\n')
        for icoil in coilnum:
            a = data['xyzc'][data['n']==icoil]
            a[-1,-1,-1] = 0.0
            for ixyzc in a[:-2]:
                coilsfile.write(" ".join(map(str,ixyzc[0]))+'\n')
            coilsfile.write(" ".join(map(str,a[-1][0]))+'\t'+str(icoil)+'\t'+'Modular' +'\n')
        coilsfile.write('end'+'\n')
    print('Finish')

#------------------------------------------  6  ----------------------------------------------------
def plotBn(h5name, bntype='current'):
    '''
    This function is used for ploting the B normal distribution on the plasma surface calculated by
    FOCUS.
    INPUT : h5name(the hdf5 file name)
            bntype(target: plot tgtBn; current: plot curBn)
    OUTPUT: mlab figures
    '''
    with h5py.File(h5name, 'r') as h5file:
        x = h5file['xsurf'].value
        y = h5file['ysurf'].value
        z = h5file['zsurf'].value
        targetBn = h5file['tgtBn'].value
        currentBn = h5file['curBn'].value
    fig = mlab.figure(bgcolor=(1,1,1),fgcolor=(0,0,0),size=(600,600))
    if bntype == 'target':
        mesh = mlab.mesh(x,y,z,scalars=targetBn, colormap='RdBu')
    else:
        mesh = mlab.mesh(x,y,z,scalars=currentBn, colormap='RdBu')

#------------------------------------------  7  ----------------------------------------------------
def plot_coils(filename, color=(0,0,1), Ncolor=1, width=2.0):
    '''
    This function plots out 3D coils in filename(coils file).
    It calls readcoil() to read coil and plot the data in mayave.
    INPUT :
            filename : coils file
            coloe    : the single color tripet float; default blue;
            Ncolor   : number of colors used for coils (usually equals the number of coil categories)
    OUTPUT: 
            mlab figures (in current figure, otherwise in new figure)
    '''
    if not os.path.exists(filename) :
        raise IOError ("File not existed. Please check again!")
    
    coil_data = readcoils(filename)
    
    if Ncolor > 1:
        c = color_array(Ncolor)
        ic = 0
        for icoil in coil_data:
            mlab.plot3d(icoil.x, icoil.y, icoil.z, color = c[ic%Ncolor], line_width=width)
            ic += 1
    else :
        for icoil in coil_data:
            mlab.plot3d(icoil.x, icoil.y, icoil.z, color = color, line_width=width)
    return coil_data

#------------------------------------------  8  ----------------------------------------------------
def color_array( N ):
    '''
    This will return a list of N rgb float triplets from colorsysp.
    '''

    if N < 1 :
        raise ValueError("Please provide a positive integer!")
    return [colorsys.hsv_to_rgb((i+1.0)/3.0, 1.0, 1.0) for i in np.linspace(0.0, 1.0, N)]
    #return [(0.0, i, 1-i) for i in np.linspace(0.0, 1.0, N)]
